$schema: https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json
name: Rust
fileTypes:
  - rs
scopeName: source.rust
patterns:
  # paths
  -
    comment: namespace (non-type, non-function path segment)
    match: (?<!\.)(?<![A-Za-z0-9_])([a-z0-9_]+)((?<!super|self)::)
    captures:
      1:
        name: entity.name.namespace.rust
      2:
        name: keyword.operator.namespace.rust
  # other
  -
    comment: boxed slice literal
    begin: (<)(\[)
    beginCaptures:
      1:
        name: punctuation.brackets.angle.rust
      2:
        name: punctuation.brackets.square.rust
    end: '>'
    endCaptures:
      0:
        name: punctuation.brackets.angle.rust
    patterns:
      - include: '#comments'
      - include: '#lifetimes'
      - include: '#punctuation'
      - include: '#types'
  # macros
  -
    comment: macro type metavariables
    name: meta.macro.metavariable.type.rust
    match: (\$)([A-Z][A-Za-z0-9_]*)((:)(block|expr|ident|item|lifetime|literal|meta|pat|path|stmt|tt|ty|vis))?
    captures:
      1:
        name: keyword.operator.macro.dollar.rust
      2:
        name: entity.name.type.metavariable.rust
      4:
        name: keyword.operator.key-value.rust
      5:
        name: variable.other.metavariable.specifier.rust
    patterns:
      - include: '#keywords'
  -
    comment: macro metavariables
    name: meta.macro.metavariable.rust
    match: (\$)([a-z][A-Za-z0-9_]*)((:)(block|expr|ident|item|lifetime|literal|meta|pat|path|stmt|tt|ty|vis))?
    captures:
      1:
        name: keyword.operator.macro.dollar.rust
      2:
        name: variable.other.metavariable.name.rust
      4:
        name: keyword.operator.key-value.rust
      5:
        name: variable.other.metavariable.specifier.rust
    patterns:
      - include: '#keywords'
  -
    comment: macro rules
    name: meta.macro.rules.rust
    begin: \bmacro_rules\b
    beginCaptures:
      0:
        name: entity.name.function.macro.rust
    end: \{
    endCaptures:
      0:
        name: punctuation.braces.rust
    patterns:
      - include: '#keywords'
      - include: '#macros'
  # attributes
  -
    comment: attributes
    name: meta.attribute.rust
    begin: '(#)(\!?)(\[)'
    beginCaptures:
      1:
        name: punctuation.definition.attribute.rust
      2:
        name: keyword.operator.attribute.inner.rust
      3:
        name: punctuation.brackets.attribute.rust
    end: '\]'
    endCaptures:
      0:
        name: punctuation.brackets.attribute.rust
    patterns:
      - include: '#keywords'
      - include: '#punctuation'
      - include: '#strings'
  # modules
  -
    comment: modules
    match: (mod)\s+([a-z][A-Za-z0-9_]*)
    captures:
      1:
        name: keyword.control.rust
      2:
        name: entity.name.module.rust
  # imports
  -
    comment: external crate imports
    name: meta.import.rust
    begin: \b(extern)\s+(crate)
    beginCaptures:
      1:
        name: keyword.control.rust
      2:
        name: keyword.other.crate.rust
    end: ;
    endCaptures:
      0:
        name: punctuation.semi.rust
    patterns:
      - include: '#comments'
      - include: '#keywords'
      - include: '#punctuation'
  # todo: perhaps scrap this meta scope and just let the paths show through
  # or alternatively just makes sure you include the namespaces
  -
    comment: use statements
    name: meta.use.rust
    begin: \b(use)\s
    beginCaptures:
      1:
        name: keyword.control.rust
    end: ;
    endCaptures:
      0:
        name: punctuation.semi.rust
    patterns:
      - include: '#comments'
      - include: '#keywords'
      - include: '#punctuation'
  - include: '#comments'
  - include: '#constants'
  - include: '#functions'
  - include: '#keywords'
  - include: '#lifetimes'
  - include: '#macros'
  - include: '#punctuation'
  - include: '#strings'
  - include: '#types'
  - include: '#variables'
repository:
  comments:
    patterns:
      -
        comment: documentation comments
        name: comment.line.documentation.rust
        match: ^\s*///.*
        patterns:
          - include: '#comments'
      -
        comment: line comments
        name: comment.line.double-slash.rust
        match: \s*//.*
        patterns:
          - include: '#comments'
      -
        comment: block comments
        name: comment.block.rust
        begin: /\*(?!\*)
        end: \*/
        patterns:
          - include: '#comments'
      -
        comment: block documentation comments
        name: comment.block.documentation.rust
        begin: /\*\*
        end: \*/
        patterns:
          - include: '#comments'
      -
        comment: inferred types, wildcard patterns, ignored params
        name: comment.char.underscore.rust
        match: \b_\w*\b
  constants:
    # todo: flesh out `type N2` vs `const N2`
    # do a separate meta for traits, types, consts, structs
    # in practice, you can't distinguish types, structs, and consts in all contexts, but you can distinguish them at the time of definition
    # they will have to default to type coloration in other locations, since that is the most common use case and structs are basically types
    # use of all caps constants will obviously fix this ambiguity
    patterns:
      -
        comment: ALL CAPS constants
        name: constant.other.caps.rust
        match: \b[A-Z]{2}[A-Z0-9_]*\b
      -
        comment: constant declarations
        match: \b(const)\s+([A-Z][A-Za-z0-9_]*)\b
        captures:
          1:
            name: keyword.control.rust
          2:
            name: constant.other.caps.rust
      # constant.numeric
      -
        comment: decimal integers and floats
        name: constant.numeric.decimal.rust
        match: \b\d[\d_]*(\.?)[\d_]*(?:(E)([+-])([\d_]+))?(f32|f64|i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)?\b
        captures:
          1:
            name: punctuation.separator.dot.decimal.rust
          2:
            name: keyword.operator.exponent.rust
          3:
            name: keyword.operator.exponent.sign.rust
          4:
            name: constant.numeric.decimal.exponent.mantissa.rust
          5:
            name: entity.name.type.numeric.rust
      -
        comment: hexadecimal integers
        name: constant.numeric.hex.rust
        match: \b0x[\da-fA-F_]+(i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)?\b
        captures:
          1:
            name: entity.name.type.numeric.rust
      -
        comment: octal integers
        name: constant.numeric.oct.rust
        match: \b0o[0-7_]+(i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)?\b
        captures:
          1:
            name: entity.name.type.numeric.rust
      -
        comment: binary integers
        name: constant.numeric.bin.rust
        match: \b0b[01_]+(i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)?\b
        captures:
          1:
            name: entity.name.type.numeric.rust
      # constant.language
      -
        comment: booleans
        name: constant.language.bool.rust
        match: \btrue|false\b
  escapes:
    comment: 'escapes: ASCII, byte, Unicode, quote, regex'
    name: constant.character.escape.rust
    match: (\\)(?:(?:(x[0-7][0-7a-fA-F])|(u(\{)[\da-fA-F]{4,6}(\}))|.))
    captures:
      1:
        name: constant.character.escape.backslash.rust
      2:
        name: constant.character.escape.bit.rust
      3:
        name: constant.character.escape.unicode.rust
      4:
        name: constant.character.escape.unicode.punctuation.rust
      5:
        name: constant.character.escape.unicode.punctuation.rust
  functions:
    # todo: create a repo item for params, and then see if you can include it only inside function defs and calls, and put it last so that perhaps the other scopes will still work
    patterns:
      -
        comment: function definition
        name: meta.function.definition.rust
        begin: \b(fn)\s+([a-z0-9_]+)(\()
        beginCaptures:
          1:
            name: keyword.control.fn.rust
          2:
            name: entity.name.function.rust
          3:
            name: punctuation.parentheses.rust
        end: \{
        endCaptures:
          0:
            name: punctuation.braces.rust
        patterns:
          - include: '#comments'
          - include: '#constants'
          - include: '#functions'
          - include: '#keywords'
          - include: '#lifetimes'
          - include: '#macros'
          - include: '#punctuation'
          - include: '#strings'
          - include: '#types'
          - include: '#variables'
      # todo: need a separate call for type calls so to speak, or do you?
      -
        comment: function/method calls, chaining
        name: meta.function.call.rust
        begin: (\.)?([a-z0-9_]+)(\()
        beginCaptures:
          1:
            name: keyword.operator.access.dot.rust
          2:
            name: entity.name.function.rust
          3:
            name: punctuation.parentheses.rust
        end: \)
        endCaptures:
          0:
            name: punctuation.parentheses.rust
        patterns:
          - include: '#comments'
          - include: '#constants'
          - include: '#functions'
          - include: '#keywords'
          - include: '#lifetimes'
          - include: '#macros'
          - include: '#punctuation'
          - include: '#strings'
          - include: '#types'
          - include: '#variables'
  keywords:
    patterns:
      -
        comment: control flow keywords
        name: keyword.control.rust
        match: \b(abstract|as|async|await|become|box|break|const|continue|do|dyn|else|enum|extern|final|for|if|impl|in|let|loop|macro|match|mod|move|override|priv|pub|ref|return|static|struct|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b
      -
        comment: fn
        name: keyword.control.fn.rust
        match: \bfn\b
      # keyword.other
      -
        comment: crate
        name: keyword.other.crate.rust
        match: \bcrate\b
      -
        comment: mut
        name: keyword.other.mut.rust
        match: \bmut\b
      # keyword.operator
      -
        comment: math operators
        name: keyword.operator.math.rust
        match: '(([+%]|(\*(?!\w)))(?!=))|(-(?!>))|(/(?!/))'
      -
        comment: logical operators
        name: keyword.operator.logical.rust
        match: (\^|\||\|\||&&|<<|>>)(?!=)
      -
        comment: macro bang and not
        name: keyword.operator.macro.not.rust
        match: '!(?!=)'
      -
        comment: logical AND, borrow references
        name: keyword.operator.borrow.and.rust
        match: '&(?![&=])'
      -
        comment: assignment operators
        name: keyword.operator.assignment.rust
        match: (-=|\*=|/=|%=|\^=|&=|\|=|<<=|>>=)
      -
        comment: single equal
        name: keyword.operator.assignment.equal.rust
        match: '(?<![<>])=(?!=|>)'
      -
        comment: comparison operators
        name: keyword.operator.comparison.rust
        match: (=(=|>)?|!=|<=|(?<!=)>=)
      -
        comment: less than, greater than (special case)
        name: keyword.operator.comparison.rust
        match: (<\s|(?<!=)>\s)
      -
        comment: namespace operator
        name: keyword.operator.namespace.rust
        match: '::'
      -
        # note: you could replace the zero length assertion here with a capture that scopes the dereferenced variable, but this way the scope of whatever is dereferenced shines through
        comment: dereference asterisk
        match: (\*)(?=\w+)
        captures:
          1:
            name: keyword.operator.dereference.rust
      -
        comment: subpattern bindng
        name: keyword.operator.subpattern.rust
        match: '@'
      -
        comment: dot access
        name: keyword.operator.access.dot.rust
        match: \.(?!\.)
      -
        comment: ranges, range patterns
        name: keyword.operator.range.rust
        match: \.{2}(=|\.)?
      -
        comment: colon
        name: keyword.operator.key-value.rust
        match: ':(?!:)'
      -
        comment: dashrocket, skinny arrow
        name: keyword.operator.arrow.skinny.rust
        match: ->
      -
        comment: hashrocket, fat arrow
        name: keyword.operator.arrow.fat.rust
        match: =>
      -
        comment: dollar macros
        name: keyword.operator.macro.dollar.rust
        match: \$
      -
        comment: question mark operator, questionably sized, macro kleene matcher
        name: keyword.operator.question.rust
        match: \?
  interpolations:
    comment: curly brace interpolations
    name: meta.interpolation.rust
    begin: '{'
    beginCaptures:
      0:
        name: punctuation.definition.interpolation.rust
    end: '}'
    endCaptures:
      0:
        name: punctuation.definition.interpolation.rust
  lifetimes:
    patterns:
      -
        comment: named lifetime parameters
        match: (['])([a-zA-Z_][0-9a-zA-Z_]*)(?!['])\b
        captures:
          1:
            name: punctuation.definition.lifetime.rust
          2:
            name: entity.name.type.lifetime.rust
      -
        comment: borrowing references to named lifetimes
        match: (\&)(['])([a-zA-Z_][0-9a-zA-Z_]*)(?!['])\b
        captures:
          1:
            name: keyword.operator.borrow.rust
          2:
            name: punctuation.definition.lifetime.rust
          3:
            name: entity.name.type.lifetime.rust
  macros:
    patterns:
      -
        comment: macros
        name: meta.macro.rust
        match: ([a-zA-Z_][0-9a-zA-Z_]*)(!)
        captures:
          1:
            name: entity.name.function.macro.rust
          2:
            name: keyword.operator.macro.not.rust
  types:
    patterns:
      -
        comment: numeric types
        match: '(?<![A-Za-z])(f32|f64|i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)\b'
        captures:
          1:
            name: entity.name.type.numeric.rust
      -
        comment: parameterized types
        begin: \b([A-Z][A-Za-z0-9]*)(<)
        beginCaptures:
          1:
            name: entity.name.type.rust
          2:
            name: punctuation.brackets.angle.rust
        end: '>'
        endCaptures:
          0:
            name: punctuation.brackets.angle.rust
        patterns:
          - include: '#comments'
          - include: '#lifetimes'
          - include: '#punctuation'
          - include: '#types'
      -
        comment: primitive types
        name: entity.name.type.primitive.rust
        match: \b(bool|char|str)\b
      -
        comment: types
        name: entity.name.type.rust
        match: '\b[A-Z][A-Za-z0-9]*\b'
      -
        comment: trait declarations
        match: \b(trait)\s+([A-Z][A-Za-z0-9]*)\b
        captures:
          1:
            name: keyword.control.rust
          2:
            name: entity.name.type.trait.rust
      -
        comment: struct declarations
        match: \b(struct)\s+([A-Z][A-Za-z0-9]*)\b
        captures:
          1:
            name: keyword.control.rust
          2:
            name: entity.name.type.struct.rust
  punctuation:
    patterns:
      -
        comment: comma
        name: punctuation.comma.rust
        match: ','
      -
        comment: curly braces
        name: punctuation.braces.rust
        match: '[{}]'
      -
        comment: parentheses
        name: punctuation.parentheses.rust
        match: '[()]'
      -
        comment: semicolon
        name: punctuation.semi.rust
        match: ;
      -
        comment: square brackets
        name: punctuation.brackets.square.rust
        match: '[\[\]]'
      -
        comment: angle brackets
        name: punctuation.brackets.angle.rust
        match: '[<>]'
  strings:
    patterns:
      -
        comment: double-quoted strings and byte strings
        name: string.quoted.double.rust
        begin: '(b?)(")'
        beginCaptures:
          1:
            name: string.quoted.byte.raw.rust
          2:
            name: punctuation.definition.string.rust
        end: '"'
        endCaptures:
          0:
            name: punctuation.definition.string.rust
        patterns:
          - include: '#escapes'
          - include: '#interpolations'
      -
        comment: double-quoted raw strings and raw byte strings
        name: string.quoted.double.rust
        begin: '(b?r)(#*)(")'
        beginCaptures:
          1:
            name: string.quoted.byte.raw.rust
          2:
            name: punctuation.definition.string.raw.rust
          3:
            name: punctuation.definition.string.rust
        end: '(")(#*)'
        endCaptures:
          1:
            name: punctuation.definition.string.rust
          2:
            name: punctuation.definition.string.raw.rust
      -
        comment: characters and bytes
        name: string.quoted.single.char.rust
        begin: "(b)?(')"
        beginCaptures:
          1:
            name: string.quoted.byte.raw.rust
          2:
            name: punctuation.definition.char.rust
        end: "'"
        endCaptures:
          0:
            name: punctuation.definition.char.rust
        patterns:
          - include: '#escapes'
  # todo: let statements
  variables:
    patterns:
      -
        comment: self
        name: variable.language.self.rust
        match: \b[Ss]elf\b
      -
        comment: super
        name: variable.language.super.rust
        match: \bsuper\b



# ALL_CAPS_CONSTANTS
# true declared constants
# numeric constants, unicode values, hex, octal, binary
# language constants - self or __module__-like things
