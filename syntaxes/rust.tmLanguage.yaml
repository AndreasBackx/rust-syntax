$schema: https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json
name: Rust
fileTypes:
  - rs
scopeName: source.rust
patterns:
  - include: '#keywords'
  - include: '#lifetimes'
  - include: '#lifetime_references'
  - include: '#punctuation'
  # comments
  -
    comment: documentation comments
    name: comment.line.documentation.rust
    match: ^\s*///.*
  -
    comment: line comments
    name: comment.line.double-slash.rust
    match: \s*//.*
  -
    comment: inferred types, wildcard patterns
    name: comment.char.underscore.rust
    match: \b_\b
  # TODO: capture * as wildcard syntax in use declarations
  # TODO: capture <> as punctuation when used in type declarations
  # strings
  -
    comment: double-quoted strings and byte strings
    name: string.quoted.double.rust
    begin: '(b?)(")'
    beginCaptures:
      1:
        name: string.quoted.byte.raw.rust
      2:
        name: punctuation.definition.string.rust
    end: '"'
    endCaptures:
      0:
        name: punctuation.definition.string.rust
    patterns:
      - include: '#escapes'
      - include: '#interpolations'
  -
    comment: double-quoted raw strings and raw byte strings
    name: string.quoted.double.rust
    begin: '(b?r)(#*)(")'
    beginCaptures:
      1:
        name: string.quoted.byte.raw.rust
      2:
        name: punctuation.definition.string.raw.rust
      3:
        name: punctuation.definition.string.rust
    end: '(")(#*)'
    endCaptures:
      1:
        name: punctuation.definition.string.rust
      2:
        name: punctuation.definition.string.raw.rust
  -
    comment: characters and bytes
    name: string.quoted.single.char.rust
    begin: "(b)?(')"
    beginCaptures:
      1:
        name: string.quoted.byte.raw.rust
      2:
        name: punctuation.definition.char.rust
    end: "'"
    endCaptures:
      0:
        name: punctuation.definition.char.rust
    patterns:
      - include: '#escapes'
  # variables
  -
    comment: self
    name: variable.language.self.rust
    match: \b[Ss]elf\b
  # constants
  # constant.numeric
  -
    comment: decimal integers and floats
    name: constant.numeric.decimal.rust
    match: \b\d[\d_]*(\.?)[\d_]*(?:(E)([+-])([\d_]+))?(f32|f64|i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)?\b
    captures:
      1:
        name: punctuation.separator.dot.decimal.rust
      2:
        name: keyword.operator.exponent.rust
      3:
        name: keyword.operator.exponent.sign.rust
      4:
        name: constant.numeric.decimal.exponent.mantissa.rust
      5:
        name: entity.name.type.numeric.rust
  -
    comment: hexadecimal integers
    name: constant.numeric.hex.rust
    match: \b0x[\da-fA-F_]+(i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)?\b
    captures:
      1:
        name: entity.name.type.numeric.rust
  -
    comment: octal integers
    name: constant.numeric.oct.rust
    match: \b0o[0-7_]+(i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)?\b
    captures:
      1:
        name: entity.name.type.numeric.rust
  -
    comment: binary integers
    name: constant.numeric.bin.rust
    match: \b0b[01_]+(i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)?\b
    captures:
      1:
        name: entity.name.type.numeric.rust
  # constant.language
  -
    comment: booleans
    name: constant.language.bool.rust
    match: \btrue|false\b
  # types
  -
    comment: numeric types
    name: entity.name.type.numeric
    match: (f32|f64|i128|i16|i32|i64|i8|isize|u128|u16|u32|u64|u8|usize)
  # punctuation
  # meta scopes
  -
    comment: attributes
    name: meta.attribute.rust
    begin: '(#)(\!?)(\[)'
    beginCaptures:
      1:
        name: punctuation.definition.attribute.rust
      2:
        name: keyword.operator.attribute.inner.rust
      3:
        name: punctuation.brackets.attribute.rust
    end: '\]'
    endCaptures:
      0:
        name: punctuation.brackets.attribute.rust
    patterns:
      # - include: '#square_brackets'
      # - include: '#parentheses'
      - include: '#punctuation'
      # - include everything needed and move to repo
  # -
  #   comment: test
  #   name: test.test.test
  #   begin: 'xxx'
  #   end: 'xxx'
  #   patterns:
  #     - include: '#lifetimes'
  #     - include: '#lifetime_references'
repository:
  escapes:
    comment: 'escapes: ASCII, byte, Unicode, quote, regex'
    name: constant.character.escape.rust
    match: (\\)(?:(?:(x[0-7][0-7a-fA-F])|(u(\{)[\da-fA-F]{4,6}(\}))|.))
    captures:
      1:
        name: constant.character.escape.backslash.rust
      2:
        name: constant.character.escape.bit.rust
      3:
        name: constant.character.escape.unicode.rust
      4:
        name: constant.character.escape.unicode.punctuation.rust
      5:
        name: constant.character.escape.unicode.punctuation.rust
  keywords:
    patterns:
      -
        comment: control flow keywords
        name: keyword.control.rust
        match: \b(abstract|as|async|await|become|box|break|const|continue|do|dyn|else|enum|extern|final|for|if|impl|in|let|loop|macro|match|mod|move|override|priv|pub|ref|return|static|struct|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b
      -
        comment: fn
        name: keyword.control.fn.rust
        match: \bfn\b
      # keyword.other
      -
        comment: crate
        name: keyword.other.crate.rust
        match: \bcrate\b
      -
        comment: mut
        name: keyword.other.mut.rust
        match: \bmut\b
      -
        comment: super
        name: keyword.other.super.rust
        match: \bsuper\b
      # keyword.operator
      -
        comment: math operators
        name: keyword.operator.math.rust
        match: '(([+/%]|(\*(?!\w)))(?!=))|(-(?!>))'

      -
        comment: logical operators
        name: keyword.operator.logical.rust
        match: (\^|\||\|\||&&|<<|>>)(?!=)
      -
        comment: macro bang and not
        name: keyword.operator.macro.not.rust
        match: '!(?!=)'
      -
        comment: logical AND, borrow references
        name: keyword.operator.borrow.and.rust
        match: '&(?![&=])'
      -
        comment: assignment operators
        name: keyword.operator.assignment.rust
        match: (-=|\*=|/=|%=|\^=|&=|\|=|<<=|>>=)
      -
        comment: single equal
        name: keyword.operator.assignment.equal.rust
        match: '(?<![<>])=(?!=|>)'
      -
        comment: comparison operators
        name: keyword.operator.comparison.rust
        match: (==|!=|<=?|(?<!=)>=?)
      -
        comment: namespace operator
        name: keyword.operator.namespace.rust
        match: '::'
      -
        comment: dereference asterisk
        match: (\*)\w+
        captures:
          1:
            name: keyword.operator.dereference.rust
      -
        comment: subpattern bindng
        name: keyword.operator.subpattern.rust
        match: '@'
      -
        comment: dot access
        name: keyword.operator.access.dot.rust
        match: \.(?!\.)
      -
        comment: ranges, range patterns
        name: keyword.operator.range.rust
        match: \.{2}(=|\.)?
      -
        comment: colon
        name: keyword.operator.key-value.rust
        match: ':(?!:)'
      -
        comment: dashrocket, skinny arrow
        name: keyword.operator.arrow.skinny.rust
        match: ->
      -
        comment: hashrocket, fat arrow
        name: keyword.operator.arrow.fat.rust
        match: =>
# $	Dollar	Macros
# ?	Question	Question mark operator, Questionably sized, Macro Kleene Matcher
  interpolations:
    comment: curly brace interpolations
    name: meta.interpolation.rust
    begin: '{'
    beginCaptures:
      0:
        name: punctuation.definition.interpolation.rust
    end: '}'
    endCaptures:
      0:
        name: punctuation.definition.interpolation.rust
  lifetimes:
    comment: named lifetime parameters
    match: (['])([a-zA-Z_][0-9a-zA-Z_]*)(?!['])\b
    captures:
      1:
        name: punctuation.definition.lifetime.rust
      2:
        name: entity.name.type.lifetime.rust
  lifetime_references:
    comment: borrowing references to named lifetimes
    match: (\&)(['])([a-zA-Z_][0-9a-zA-Z_]*)(?!['])\b
    captures:
      1:
        name: keyword.operator.borrow.rust
      2:
        name: punctuation.definition.lifetime.rust
      3:
        name: entity.name.type.lifetime.rust
  punctuation:
    patterns:
      -
        comment: comma
        name: punctuation.comma.rust
        match: ','
      -
        comment: curly braces
        name: punctuation.braces.rust
        match: '[{}]'
      -
        comment: parentheses
        name: punctuation.parentheses.rust
        match: '[()]'
      -
        comment: semicolon
        name: punctuation.semi.rust
        match: ;
      -
        comment: square brackets
        name: punctuation.brackets.square.rust
        match: '[\[\]]'


# plain comments //
# documentation comments ///
# that #[stuff] should have its own scope, it's comment-like

# keywords for control flow
# keyword operators
# special keywords like crate

# true declared constants
# numeric constants, unicode values, hex, octal, binary
# language constants - self or __module__-like things

# operators to address:
# +	Plus	Addition, Trait Bounds, Macro Kleene Matcher
# -	Minus	Subtraction, Negation
# *	Star	Multiplication, Dereference, Raw Pointers, Macro Kleene Matcher
# /	Slash	Division
# %	Percent	Remainder
# ^	Caret	Bitwise and Logical XOR
# !	Not	Bitwise and Logical NOT, Macro Calls, Inner Attributes, Never Type
# &	And	Bitwise and Logical AND, Borrow, References, Reference patterns
# |	Or	Bitwise and Logical OR, Closures, Match
# &&	AndAnd	Lazy AND, Borrow, References, Reference patterns
# ||	OrOr	Lazy OR, Closures
# <<	Shl	Shift Left, Nested Generics
# >>	Shr	Shift Right, Nested Generics
# +=	PlusEq	Addition assignment
# -=	MinusEq	Subtraction assignment
# *=	StarEq	Multiplication assignment
# /=	SlashEq	Division assignment
# %=	PercentEq	Remainder assignment
# ^=	CaretEq	Bitwise XOR assignment
# &=	AndEq	Bitwise And assignment
# |=	OrEq	Bitwise Or assignment
# <<=	ShlEq	Shift Left assignment
# >>=	ShrEq	Shift Right assignment, Nested Generics
# =	Eq	Assignment, Attributes, Various type definitions
# ==	EqEq	Equal
# !=	Ne	Not Equal
# >	Gt	Greater than, Generics, Paths
# <	Lt	Less than, Generics, Paths
# >=	Ge	Greater than or equal to, Generics
# <=	Le	Less than or equal to
# @	At	Subpattern binding
# _	Underscore	Wildcard patterns, Inferred types
# .	Dot	Field access, Tuple index
# ..	DotDot	Range, Struct expressions, Patterns
# ...	DotDotDot	Variadic functions, Range patterns
# ..=	DotDotEq	Inclusive Range, Range patterns
# ,	Comma	Various separators
# ;	Semi	Terminator for various items and statements, Array types
# :	Colon	Various separators
# ::	PathSep	Path separator
# ->	RArrow	Function return type, Closure return type
# =>	FatArrow	Match arms, Macros
# #	Pound	Attributes
# $	Dollar	Macros
# ?	Question	Question mark operator, Questionably sized
